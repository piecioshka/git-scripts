#!/usr/bin/env node

const exec = require("child_process").exec;
const path = require("path");
const process = require("process");
const {
  isFile,
  isDirectory,
  isGitRepository,
  getDirectoryList,
} = require("./__shared");

const workspacePath = process.argv[2] || process.cwd();

function isLocalGitRepository(pathname) {
  return new Promise((resolve, reject) => {
    exec(
      `cd ${pathname} && git config remote.origin.url`,
      (err, stdout, stderr) => {
        if (err || stdout.length === 0) {
          return void resolve(true);
        }

        resolve(false);
      }
    );
  });
}

function isDirtyGitRepository(pathname) {
  return new Promise((resolve, reject) => {
    exec(
      `cd ${pathname} && git status --porcelain 2>/dev/null | wc -l`,
      (err, stdout, stderr) => {
        if (err) {
          return void reject(err);
        }

        resolve(Boolean(Number(stdout)));
      }
    );
  });
}

function updateGitRepository(pathname) {
  return new Promise((resolve, reject) => {
    exec(
      `cd ${pathname} && git fetch -p && git pull --all`,
      (err, stdout, stderr) => {
        if (err) {
          return void resolve(false);
        }

        resolve(true);
      }
    );
  });
}

async function describePathname(pathname) {
  try {
    const result = {};
    result.isFile = isFile(pathname);
    result.isDirectory = isDirectory(pathname);
    result.isGitRepository = isGitRepository(pathname);
    result.isLocalGitRepository = result.isGitRepository
      ? await isLocalGitRepository(pathname)
      : false;
    result.isDirtyGitRepository = result.isGitRepository
      ? await isDirtyGitRepository(pathname)
      : false;
    result.isUpdated = result.isGitRepository
      ? await updateGitRepository(pathname)
      : false;
    return result;
  } catch (err) {
    console.log("Caught an Error");
    console.error(err);
  }
}

function setupPromiseLoop(files) {
  return files.reduce((promise, file) => {
    const pathname = path.resolve(workspacePath, file);
    const basename = path.basename(pathname);

    return promise
      .then(() => {
        return describePathname(pathname);
      })
      .then((descriptor) => {
        const output = [];

        if (descriptor.isFile) {
          output.push("[file]");
        } else {
          if (descriptor.isUpdated) {
            output.push("[updated]");
          }

          if (!descriptor.isGitRepository) {
            output.push("[not a git repo]");
          }

          if (descriptor.isDirtyGitRepository) {
            output.push("[dirty repo]");
          }

          if (descriptor.isLocalGitRepository) {
            output.push("[local git repo]");
          }
        }

        output.push(basename);
        console.log(output.join(" "));
      })
      .catch((err) => {
        console.log("Caught an Error");
        console.error(err);
      });
  }, Promise.resolve());
}

console.log(`\nWorkspace: "${path.resolve(workspacePath)}"\n`);

async function main() {
  const files = await getDirectoryList(workspacePath);
  await setupPromiseLoop(files);
}

main().catch(console.error);
