#!/usr/bin/env node

const path = require("node:path");
const process = require("node:process");
const { runCommand } = require("../shared/__shared");
const {
  isFile,
  isDirectory,
  getFilesAndDirectories,
} = require("../shared/__filesystem");
const {
  getGitBranchName,
  isGitRepository,
  isLocalGitRepository,
} = require("../shared/__git");
const {
  red,
  green,
  yellow,
  blue,
  magenta,
  cyan,
  gray,
} = require("../shared/__colors");
const { isPrivateGitRepository } = require("../shared/__git_origin");

async function isDirtyGitRepository(pathname) {
  if (!isGitRepository(pathname)) return false;

  try {
    const command = "git status --porcelain 2>/dev/null | wc -l";
    const output = await runCommand(command, { cwd: pathname });
    return Boolean(Number(output));
  } catch (error) {
    if (error) {
      console.log(
        `${red("[error]")} (dirty git repository) ${path.basename(pathname)}`,
      );
      console.error(error);
    }
    return false;
  }
}

async function updateGitRepository(pathname) {
  const isLocalRepository = await isLocalGitRepository(pathname);
  if (!isGitRepository(pathname) || isLocalRepository) return false;

  try {
    const command = "git fetch -p && git pull --all";
    await runCommand(command, { cwd: pathname });
  } catch (error) {}

  return true;
}

async function describePathname(pathname) {
  const start = Date.now();
  const result = {};
  result.isFile = isFile(pathname);
  result.isDirectory = isDirectory(pathname);
  result.isRepository = isGitRepository(pathname);
  result.isLocalRepository = await isLocalGitRepository(pathname);
  result.isDirtyRepository = await isDirtyGitRepository(pathname);
  result.isUpdated = await updateGitRepository(pathname);
  result.branchName = await getGitBranchName(pathname);
  result.isPrivateRepository = await isPrivateGitRepository(pathname);
  const end = Date.now();
  result.elapsedTime = end - start;
  return result;
}

function setupPromiseLoop(files, workspacePath) {
  return files.reduce((promise, file) => {
    const pathname = path.resolve(workspacePath, file);

    return promise
      .then(() => describePathname(pathname))
      .then((descriptor) => {
        const {
          elapsedTime,
          isFile,
          isRepository,
          isDirtyRepository,
          isUpdated,
          isLocalRepository,
          branchName,
          isPrivateRepository,
        } = descriptor;
        const output = [];
        output.push(gray(`[${elapsedTime}ms]`));

        if (isFile) {
          output.push(blue("[file]"));
        } else if (isRepository) {
          if (isDirtyRepository) {
            output.push(cyan("[dirty]"));
          }

          if (isUpdated) {
            output.push(green("[updated]"));
          }

          if (isLocalRepository) {
            output.push("[local Git repo]");
          }
        } else {
          output.push("[not a Git repo]");
        }

        output.push(path.basename(pathname));

        if (isRepository) {
          if (branchName) {
            output.push(magenta(`[${branchName}]`));
          }

          if (isPrivateRepository) {
            output.push(yellow(`[🔐 private]`));
          }
        }

        console.log(output.join(" "));
      })
      .catch((err) => {
        console.error(err.message);
      });
  }, Promise.resolve());
}

async function main() {
  const workspacePath = process.argv[2] || process.cwd();
  const files = getFilesAndDirectories(workspacePath);
  await setupPromiseLoop(files, workspacePath);
}

main().catch(console.error);
