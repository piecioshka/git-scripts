#!/usr/bin/env node

const path = require("node:path");
const process = require("node:process");
const { runCommand } = require("../shared/__shared");
const {
  isFile,
  isDirectory,
  getFilesAndDirectories,
} = require("../shared/__filesystem");
const {
  getGitBranchName,
  isGitRepository,
  isLocalOnlyGitRepository,
  isDirtyGitRepository,
  isGitWorktree,
} = require("../shared/__git");
const { isPrivateGitRepository } = require("../shared/__git_origin");
const {
  dimGray,
  italic,
  red,
  green,
  yellow,
  blue,
  magenta,
  brown,
  gray,
  darkGreen,
} = require("../shared/__colors");

const ALREADY_UP_TO_DATE = "up-to-date";

async function updateGitRepository(pathname) {
  const command = "git -c color.ui=always pull --all";
  return await runCommand(command, { cwd: pathname });
}

async function describePathname(pathname) {
  const start = Date.now();
  const result = {};
  result.isFile = isFile(pathname);
  result.isDirectory = isDirectory(pathname);
  result.isRepository = isGitRepository(pathname);
  result.isWorktree = isGitWorktree(pathname);
  result.isLocalOnlyRepository = await isLocalOnlyGitRepository(pathname);
  result.isDirtyRepository = await isDirtyGitRepository(pathname);
  const shouldBeUpdated =
    (result.isRepository || result.isWorktree) &&
    !result.isLocalOnlyRepository &&
    !result.isDirtyRepository;
  if (shouldBeUpdated) {
    const status = await updateGitRepository(pathname);
    if (typeof status === "string" && status.includes("Already up to date.")) {
      result.updateStatus = ALREADY_UP_TO_DATE;
    } else if (typeof status === "string") {
      result.updateStatus = status;
    } else if (status instanceof Error) {
      result.updateStatus = false;
    } else {
      result.updateStatus = false;
    }
  }
  result.branchName = await getGitBranchName(pathname);
  result.isPrivateRepository = await isPrivateGitRepository(pathname);
  const end = Date.now();
  result.elapsedTime = end - start;
  return result;
}

function setupPromiseLoop(files, workspacePath) {
  return files.reduce((promise, file) => {
    const pathname = path.resolve(workspacePath, file);

    return promise
      .then(() => describePathname(pathname))
      .then((descriptor) => {
        const {
          elapsedTime,
          isFile,
          isRepository,
          isWorktree,
          isDirtyRepository,
          updateStatus,
          isLocalOnlyRepository,
          branchName,
          isPrivateRepository,
        } = descriptor;
        const output = [];

        if (isFile) {
          output.push(blue("[file]"));
        } else if (isRepository) {
          if (isDirtyRepository) {
            output.push(red("[dirty repo]"));
          }

          if (updateStatus) {
            switch (updateStatus) {
              case ALREADY_UP_TO_DATE:
                output.push(darkGreen(`[${ALREADY_UP_TO_DATE}]`));
                break;
              case false:
                output.push(red("[update failed]"));
                break;
              default:
                output.push(green("[updated]"));
                break;
            }
          }

          if (isLocalOnlyRepository) {
            output.push("[local repo]");
          }
        } else if (isWorktree) {
          output.push(dimGray(italic("[worktree]")));
        } else {
          output.push(brown("[not repo]"));
        }

        output.push(path.basename(pathname));

        if (isRepository) {
          if (branchName) {
            output.push(magenta(`[${branchName}]`));
          }

          if (isPrivateRepository) {
            output.push(yellow(`[ðŸ” private]`));
          } else if (isPrivateRepository === null) {
            output.push(dimGray(`[unknown visibility]`));
          }
        }

        output.push(gray(italic(`+${elapsedTime}ms`)));

        console.log(output.join(" "));
        if (updateStatus && updateStatus !== ALREADY_UP_TO_DATE) {
          console.log(updateStatus);
        }
      })
      .catch((err) => {
        console.error(err.message);
      });
  }, Promise.resolve());
}

async function main() {
  const workspacePath = process.argv[2] || process.cwd();
  const files = getFilesAndDirectories(workspacePath);
  await setupPromiseLoop(files, workspacePath);
}

main().catch(console.error);
