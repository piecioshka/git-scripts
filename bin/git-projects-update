#!/usr/bin/env node

const path = require("node:path");
const process = require("node:process");
const { runCommand } = require("../shared/__shared");
const {
  isFile,
  isDirectory,
  getFilesAndDirectories,
} = require("../shared/__filesystem");
const {
  getGitBranchName,
  isGitRepository,
  isLocalOnlyGitRepository,
  isDirtyGitRepository,
} = require("../shared/__git");
const { isPrivateGitRepository } = require("../shared/__git_origin");
const {
  dimGray,
  italic,
  red,
  green,
  yellow,
  blue,
  magenta,
  brown,
  gray,
} = require("../shared/__colors");

async function updateGitRepository(pathname) {
  try {
    const command = "git fetch -p && git pull --all";
    await runCommand(command, { cwd: pathname });
  } catch (error) {}

  return true;
}

async function describePathname(pathname) {
  const start = Date.now();
  const result = {};
  result.isFile = isFile(pathname);
  result.isDirectory = isDirectory(pathname);
  result.isRepository = isGitRepository(pathname);
  result.isLocalOnlyRepository = await isLocalOnlyGitRepository(pathname);
  result.isDirtyRepository = await isDirtyGitRepository(pathname);
  result.isUpdated =
    result.isRepository &&
    !result.isLocalOnlyRepository &&
    !result.isDirtyRepository
      ? await updateGitRepository(pathname)
      : false;
  result.branchName = await getGitBranchName(pathname);
  result.isPrivateRepository = await isPrivateGitRepository(pathname);
  const end = Date.now();
  result.elapsedTime = end - start;
  return result;
}

function setupPromiseLoop(files, workspacePath) {
  return files.reduce((promise, file) => {
    const pathname = path.resolve(workspacePath, file);

    return promise
      .then(() => describePathname(pathname))
      .then((descriptor) => {
        const {
          elapsedTime,
          isFile,
          isRepository,
          isDirtyRepository,
          isUpdated,
          isLocalOnlyRepository,
          branchName,
          isPrivateRepository,
        } = descriptor;
        const output = [];

        if (isFile) {
          output.push(blue("[file]"));
        } else if (isRepository) {
          if (isDirtyRepository) {
            output.push(red("[* dirty]"));
          }

          if (isUpdated) {
            output.push(green("[updated]"));
          }

          if (isLocalOnlyRepository) {
            output.push("[local Git repo]");
          }
        } else {
          output.push(brown("[notrepo]"));
        }

        output.push(path.basename(pathname));

        if (isRepository) {
          if (branchName) {
            output.push(magenta(`[${branchName}]`));
          }

          if (isPrivateRepository) {
            output.push(yellow(`[🔐 private]`));
          } else if (isPrivateRepository === null) {
            output.push(dimGray(`[unknown visibility]`));
          }
        }

        output.push(gray(italic(`+${elapsedTime}ms`)));

        console.log(output.join(" "));
      })
      .catch((err) => {
        console.error(err.message);
      });
  }, Promise.resolve());
}

async function main() {
  const workspacePath = process.argv[2] || process.cwd();
  const files = getFilesAndDirectories(workspacePath);
  await setupPromiseLoop(files, workspacePath);
}

main().catch(console.error);
